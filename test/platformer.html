<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<title>Platformer using Underreact</title>
<!-- platformer.html (part of Underreact) -->
<!--

The copyright and license information below applies to this file as an
independent work. Other files commonly used or bundled with this one
may have different authors and different posted licenses.

-->
<!--

Copyright (c) 2012, Ross Angle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-->
<meta name="viewport"
    content="initial-scale = 1.0, maximum-scale = 1.0" />
<style type="text/css">
</style>

<script type="text/javascript" src="../lib/lathe.js"></script>

<script type="text/javascript">"use strict";
var _ = rocketnia.lathe;
</script>
<script type="text/javascript" src="../src/underreact-async.js"
    ></script>
<script type="text/javascript" src="../src/underreact-behaviors.js"
    ></script>
<script type="text/javascript" src="../src/underreact-lambda.js"
    ></script>
<script type="text/javascript" src="tests.js"></script>
<script type="text/javascript">"use strict";
_.appendDom( window, { load: function () {
    
    var atom = typeAtom( 0, null );
    
    // TODO: Use something like this for Lathe.js's _.defer(). Right
    // here we're non-modularly hacking it in (or rather we aren't,
    // since right now the crucial line is commented out).
    //
    // TODO: Actually, see if we need this at all. This code is
    // commented out, and it doesn't seem to make a difference.
    //
    // TODO: Test postMessage on various browsers.
    //
    var customDeferredFuncs = [];
    var customDefer = function ( deferredFunc ) {
        customDeferredFuncs.push( deferredFunc );
        postMessage( "customDefer", "*" );
    };
    _.appendDom( window, { message: function ( e ) {
        if ( e.source === window
            && e.data === "customDefer"
            && customDeferredFuncs.length !== 0 )
            customDeferredFuncs.pop()();
    } } );
//    _.defer = customDefer;
    var customDefer = _.defer;
    
    var w = 200, h = 200;
    var canvas = _.dom( "canvas", { width: "" + w, height: "" + h } );
    var ctx = canvas.getContext( "2d" );
    
    function elPos( el ) {
        // NOTE: This is loosely taken from an example at
        // <http://www.kirupa.com/html5/get_element_position_using_javascript.htm>.
        var x = 0, y = 0;
        for ( var e = el; e !== null; e = e.offsetParent ) {
            x += e.offsetLeft - e.scrollLeft + e.clientLeft;
            y += e.offsetTop - e.scrollTop + e.clientTop;
        }
        return { x: x, y: y };
    }
    
    // TODO: Test requestAnimationFrame on various browsers. Some
    // important browsers may not support it or may only support it
    // under a prefix.
    var latestShapes = [];
    var drawNecessary = true;
    function draw() {
        if ( !drawNecessary )
            return;
        
        drawNecessary = false;
        
        ctx.fillStyle = "#000000";
        ctx.fillRect( 0, 0, w, h );
        var cPos = elPos( canvas );
        _.arrEach( latestShapes, function ( shape ) {
            function parseCoord( coord ) {
                if ( coord[ 0 ] === "viewport" ) {
                    return {
                        x: coord[ 1 ] - cPos.x,
                        y: coord[ 2 ] - cPos.y
                    };
                } else if ( coord[ 0 ] === "canvas" ) {
                    return { x: coord[ 1 ], y: coord[ 2 ] };
                } else {
                    throw new Error();
                }
            }
            if ( shape[ 0 ] === "rect" ) {
                ctx.fillStyle = "" + shape[ 1 ];
                var tl = parseCoord( shape[ 2 ] );
                ctx.fillRect( tl.x, tl.y, shape[ 3 ], shape[ 4 ] );
            } else {
                throw new Error();
            }
        } );
    }
    requestAnimationFrame( draw );
    
    function sortByPrim( a, b ) {
        return a < b ? -1 : b < a ? 1 : 0;
    }
    function sortByMap( func, opt_thenSort ) {
        if ( opt_thenSort === void 0 )
            opt_thenSort = sortByPrim;
        return function ( a, b ) {
            return opt_thenSort( func( a ), func( b ) );
        };
    }
    function sortByTrials( sorters ) {
        // TODO: See if this will come in handy.
        return function ( a, b ) {
            var anyResult = _.arrAny( sorters, function ( sorter ) {
                var thisResult = sorter( a, b );
                if ( thisResult === 0 )
                    return false;
                return { val: thisResult };
            } );
            return anyResult ? anyResult.val : 0;
        };
    }
    
    function makeDeMonCaps() {
        var resource = behDemandMonitor( customDefer );
        return {
            put: {
                earlyInputType: atom,
                beh: resource.demander
            },
            get: {
                earlyInputType: atom,
                beh: resource.monitor
            }
        };
    }
    
    function animatedStateResourceToCaps( resource ) {
        return {
            put: {
                earlyInputType: atom,
                beh: resource.demander
            },
            get: {
                earlyInputType: atom,
                beh: resource.monitor
            }
        };
    }
    function makeAnimatedStateCaps(
        initialState, compareStates, transitions ) {
        
        return animatedStateResourceToCaps( behAnimatedState(
            customDefer, initialState, compareStates, transitions ) );
    }
    
    function makeInt32AnimatedStateCaps() {
        
        // We validate each entry and just filter it out if it's
        // invalid. Specifically, it must be one of the following:
        //
        // - A four-element Array containing the string "replace", a
        //   signed 32-bit int, a signed 32-bit int, and a positive
        //   integer duration in milliseconds.
        //
        // - A five-element Array containing the string "rangeAdd", a
        //   signed 32-bit int lower bound (inclusive), a signed
        //   32-bit int upper bound (inclusive), a signed 32-bit int
        //   which can be added to any int in that range without
        //   overflowing, and a positive integer duration in
        //   milliseconds. The lower bound must be less than or equal
        //   to the upper bound.
        
        // TODO: Find a more elegant approach using modulo arithmetic.
        
        function isState( x ) {
            return x === ~~x;
        }
        function isIncrement( x ) {
            return x === ~~x;
        }
        function isIntDuration( x ) {
            return isValidDuration( x ) && x % 1 === 0;
        }
        
        return makeAnimatedStateCaps( 0, sortByPrim, {
            replace: function ( rule ) {
                rule = JSON.parse( rule );
                if ( !(true
                    && _.likeArray( rule )
                    && rule.length === 3
                    && isState( rule[ 0 ] )
                    && isState( rule[ 1 ] )
                    && isIntDuration( rule[ 2 ] )
                ) )
                    return [];
                return [ function ( oldVal ) {
                    if ( oldVal !== rule[ 0 ] )
                        return null;
                    return {
                        newVal: rule[ 1 ],
                        cooldownMillis: rule[ 2 ]
                    };
                } ];
            },
            rangeAdd: function ( rule ) {
                rule = JSON.parse( rule );
                if ( !(true
                    && _.likeArray( rule )
                    && rule.length === 4
                    && isState( rule[ 0 ] )
                    && isState( rule[ 1 ] )
                    && rule[ 0 ] <= rule[ 1 ]
                    && isIncrement( rule[ 2 ] )
                    && isState( rule[ 0 ] + rule[ 2 ] )
                    && isState( rule[ 1 ] + rule[ 2 ] )
                    && isIntDuration( rule[ 3 ] )
                ) )
                    return [];
                return [ function ( oldVal ) {
                    if ( !(rule[ 0 ] <= oldVal
                        && oldVal <= rule[ 1 ]) )
                        return null;
                    return {
                        newVal: oldVal + rule[ 2 ],
                        cooldownMillis: rule[ 3 ]
                    };
                } ];
            }
        } );
    }
    function ruleReplace( oldVal, newVal, cooldownMillis ) {
        return [ "replace",
            JSON.stringify( [ oldVal, newVal, cooldownMillis ] ) ];
    }
    function ruleRangeAdd( oldMin, oldMax, inc, cooldownMillis ) {
        return [ "rangeAdd", JSON.stringify(
            [ oldMin, oldMax, inc, cooldownMillis ] ) ];
    }
    
    var stableKeyboardAnim =
        makeAnimatedStateCaps( [], sortByTrials(), {
        
        set: function ( newVal ) {
            newVal = JSON.parse( newVal );
            return [ function ( oldVal ) {
                // TODO: Figure out what frame rate would be
                // appropriate for the keyboard input. Perhaps we
                // should just make a new state resource that just
                // prolongs a state until the next valid replacement
                // comes along. Then it'll effectively be this with a
                // cooldown of 0, even though we can't actually use 0
                // here without entering an infinite loop.
                return { cooldownMillis: ~~(1000 / 30),
                    newVal: newVal };
            } ];
        }
    } );
    var shapesDeMon = makeDeMonCaps();
    var heroForcesDeMon = makeDeMonCaps();
    var heroVolitionAnim = makeAnimatedStateCaps(
        {
            precedence: 0,
            goingLeft: false,
            goingRight: false,
            jumping: false
        },
        sortByMap( function ( state ) {
            return state.precedence;
        } ),
        {
            controlAndEnv: function ( rule ) {
                rule = JSON.parse( rule );
                var controlLeft = rule[ 0 ];
                var controlRight = rule[ 1 ];
                var controlJump = rule[ 2 ];
                var envStanding = rule[ 3 ];
                var envJumpPropelled = rule[ 4 ];
                return [ function ( oldVal ) {
                    return { cooldownMillis: ~~(1000 / 30), newVal: {
                        precedence: 0,
                        goingLeft: controlLeft && !controlRight,
                        goingRight: controlRight && !controlLeft,
                        jumping: controlJump &&
                            (envStanding ||
                                (envJumpPropelled && oldVal.jumping))
                    } };
                } ];
            }
        } );
    // TODO: Extract some of these magic numbers into a more global
    // config location.
    var defaultJumpPropelMillis = 500;
    var heroNaturalW = 20;
    var heroNaturalH = 20;
    var heroKineticsAnim = makeAnimatedStateCaps(
        {
            precedence: 0,
            vx: 0,
            vy: 0,
            centerX: 0,
            centerY: 0,
            naturalW: heroNaturalW,
            naturalH: heroNaturalH,
            squishW: heroNaturalW,
            squishH: heroNaturalH,
            standing: 0,
            jumpPropelRemainingMillis: defaultJumpPropelMillis
        },
        sortByMap( function ( state ) {
            return state.precedence;
        } ),
        {
            applyForces: function ( rule ) {
                
                var forces = _.arrMap( JSON.parse( rule ),
                    function ( force ) {
                    
                    if ( force[ 0 ] === "solid" )
                        return {
                            type: "solid",
                            
                            // TODO: Figure out which of these groups
                            // to actually use in the Array
                            // representation of this force.
                            
                            tlx: force[ 1 ],
                            tly: force[ 2 ],
                            w: force[ 3 ],
                            h: force[ 4 ],
                            
                            minX: force[ 1 ],
                            minY: force[ 2 ],
                            maxX: force[ 1 ] + force[ 3 ],
                            maxY: force[ 2 ] + force[ 4 ]
                        };
                    else if ( force[ 0 ] === "accel" )
                        return {
                            type: "accel",
                            // TODO: Clarify that these are measured
                            // in distance units per millisecond per
                            // millisecond.
                            x: force[ 1 ],
                            y: force[ 2 ]
                        };
                    else if ( force[ 0 ] === "jump" )
                        return {
                            type: "jump",
                            // TODO: Clarify that these are measured
                            // in distance units per millisecond.
                            vyDuring: force[ 1 ],
                            vyAfterward: force[ 2 ]
                        };
                    else
                        throw new Error();
                } );
                
                var ax = 0;
                var ay = 0;
                _.arrEach( forces, function ( force ) {
                    if ( force.type !== "accel" )
                        return;
                    ax += force.x;
                    ay += force.y;
                } );
                
                var jumping = false;
                var jumpvyDuring = 1 / 0;
                var jumpvyAfterward = 1 / 0;
                _.arrEach( forces, function ( force ) {
                    if ( force.type !== "jump" )
                        return;
                    jumping = true;
                    // TODO: Right now these are minimum'd separately.
                    // See if we should somehow compare them as
                    // inseparable pairs.
                    jumpvyDuring = Math.min( jumpvyDuring,
                        force.vyDuring );
                    jumpvyAfterward = Math.min( jumpvyAfterward,
                        force.vyAfterward );
                } );
                
                return [ function ( ov ) {
                    
                    // TODO: Extract the magic number 30 into a more
                    // global config location.
                    var fps = 30;
                    var dtMillis = 1000 / fps;
                    
                    var desiredfvx = ov.vx + ax * dtMillis;
                    var desiredfvy = ov.vy + ay * dtMillis;
                    var desiredmidvx = (ov.vx + desiredfvx) / 2;
                    var desiredmidvy = (ov.vy + desiredfvy) / 2;
                    var velocityIsBasedOnJump =
                        jumping && jumpvyDuring < desiredmidvy;
                    if ( velocityIsBasedOnJump )
                        desiredmidvy = jumpvyDuring;
                    var desiredcx =
                        ov.centerX + (desiredmidvx * dtMillis);
                    var desiredcy =
                        ov.centerY + (desiredmidvy * dtMillis);
                    
                    var availableRect = {
                        minX: -1 / 0,
                        maxX: 1 / 0,
                        minY: -1 / 0,
                        maxY: 1 / 0
                    };
                    _.arrEach( forces, function ( force ) {
                        if ( force.type !== "solid" )
                            return;
                        if ( desiredcx < force.minX )
                            availableRect.maxX = Math.min(
                                availableRect.maxX, force.minX );
                        if ( force.maxX < desiredcx )
                            availableRect.minX = Math.max(
                                availableRect.minX, force.maxX );
                        if ( desiredcy < force.minY )
                            availableRect.maxY = Math.min(
                                availableRect.maxY, force.minY );
                        if ( force.maxY < desiredcy )
                            availableRect.minY = Math.max(
                                availableRect.minY, force.maxY );
                    } );
                    
                    
                    var finalRect = {
                        minX: desiredcx - (ov.naturalW / 2),
                        maxX: desiredcx + (ov.naturalW / 2),
                        minY: desiredcy - (ov.naturalH / 2),
                        maxY: desiredcy + (ov.naturalH / 2)
                    };
                    
                    if ( availableRect.maxY - availableRect.minY <
                        ov.naturalH ) {
                        
                        finalRect.minY = availableRect.minY;
                        finalRect.maxY = availableRect.maxY;
                        
                    } else if (
                        availableRect.maxY < finalRect.maxY ) {
                        
                        var diff =
                            availableRect.maxY - finalRect.maxY;
                        finalRect.minY += diff;
                        finalRect.maxY += diff;
                        
                    } else if (
                        finalRect.minY < availableRect.minY ) {
                        
                        var diff =
                            availableRect.minY - finalRect.minY;
                        finalRect.minY += diff;
                        finalRect.maxY += diff;
                    }
                    
                    if ( availableRect.maxX - availableRect.minX <
                        ov.naturalW ) {
                        
                        finalRect.minX = availableRect.minX;
                        finalRect.maxX = availableRect.maxX;
                        
                    } else if (
                        availableRect.maxX < finalRect.maxX ) {
                        
                        var diff =
                            availableRect.maxX - finalRect.maxX;
                        finalRect.minX += diff;
                        finalRect.maxX += diff;
                        
                    } else if (
                        finalRect.minX < availableRect.minX ) {
                        
                        var diff =
                            availableRect.minX - finalRect.minX;
                        finalRect.minX += diff;
                        finalRect.maxX += diff;
                    }
                    
                    
                    var actualcx =
                        (finalRect.minX + finalRect.maxX) / 2;
                    var actualcy =
                        (finalRect.minY + finalRect.maxY) / 2;
                    var actualmidvx =
                        (actualcx - ov.centerX) / dtMillis;
                    var actualmidvy =
                        (actualcy - ov.centerY) / dtMillis;
                    
                    // NOTE: We clamp these toward zero, rather than
                    // letting the entity bounce off walls. Even if we
                    // didn't do this clamping, the entity's bouncing
                    // would be erratic. It would not bounce if it
                    // collided at exactly the same time as a frame
                    // step, and it would bounce at 100% its original
                    // speed if it collided halfway between frames.
                    var actualfvx = ov.vx + (actualmidvx - ov.vx) * 2;
                    if ( ov.vx * actualfvx < 0 )
                        actualfvx = 0;
                    var actualfvy = ov.vy + (actualmidvy - ov.vy) * 2;
                    if ( ov.vy * actualfvy < 0 )
                        actualfvy = 0;
                    
                    if ( velocityIsBasedOnJump )
                        actualfvy = jumpvyAfterward;
                    
                    
                    var standing =
                        finalRect.maxY === availableRect.maxY;
                    
                    
                    return { cooldownMillis: ~~dtMillis, newVal: {
                        precedence: 0,
                        vx: actualfvx,
                        vy: actualfvy,
                        centerX: actualcx,
                        centerY: actualcy,
                        naturalW: ov.naturalW,
                        naturalH: ov.naturalH,
                        squishW: finalRect.maxX - finalRect.minX,
                        squishH: finalRect.maxY - finalRect.minY,
                        standing: standing,
                        jumpPropelRemainingMillis:
                            jumping ?
                                Math.max( 0,
                                    ov.jumpPropelRemainingMillis -
                                        dtMillis ) :
                            standing ? defaultJumpPropelMillis :
                            0
                    } };
                } ];
            }
        } );
    var drummerAnim = makeInt32AnimatedStateCaps();
    var sprinterAnim = makeInt32AnimatedStateCaps();
    var wasdXAnim = makeInt32AnimatedStateCaps();
    var wasdYAnim = makeInt32AnimatedStateCaps();
    
    var KEYS = {
        a: 65,
        d: 68,
        s: 83,
        w: 87
    };
    
    runLambdaLangConvenient( [ 1, 49 ], {
        volatileKeyboard: {
            earlyInputType: atom,
            beh: behEventfulSource( {
                apologyVal: JSON.stringify( null ),
                listenOnUpdate: function ( listener ) {
                    var keysObj = {};
                    var keysArr = [];
                    
                    function keyCode( event ) {
                        return event.which ||
                            event.keyCode;  // IE
                    }
                    
                    _.appendDom( window, { keydown: function ( e ) {
                        var key = keyCode( e );
                        if ( keysObj[ key ] )
                            return;
                        keysObj[ key ] = true;
                        keysArr.push( key );
                        listener( JSON.stringify( keysArr ) );
                    } } );
                    _.appendDom( window, { keyup: function ( e ) {
                        var key = keyCode( e );
                        if ( !keysObj[ key ] )
                            return;
                        delete keysObj[ key ];
                        keysArr = _.arrKeep( keysArr, function ( k ) {
                            return k !== key;
                        } );
                        listener( JSON.stringify( keysArr ) );
                    } } );
                },
                intervalMillis: 1,
                stabilityMillis: 6
            } )
        },
        mouse: {
            earlyInputType: atom,
            beh: behMouseQuery( {
                intervalMillis: 1,
                // NOTE: This setting makes the biggest difference for
                // the responsiveness of the interface. At 10 ms, it's
                // noticeably laggier than canvas-control-group.html.
                // At 4 ms, it noticeably flickers due to all the gaps
                // of inactivity.
                // TODO: Since this is likely to have a slightly
                // different optimal value depending on the 
                stabilityMillis: 6
            } )
        },
        stableKeyboardAnimPut: stableKeyboardAnim.put,
        stableKeyboard: stableKeyboardAnim.get,
        showShape: shapesDeMon.put,
        shapesDeMonGet: shapesDeMon.get,
        heroForcesDeMonPut: heroForcesDeMon.put,
        heroForcesDeMonGet: heroForcesDeMon.get,
        heroVolitionAnimPut: heroVolitionAnim.put,
        heroVolitionAnimGet: heroVolitionAnim.get,
        heroKineticsAnimPut: heroKineticsAnim.put,
        heroKineticsAnimGet: heroKineticsAnim.get,
        drummerAnimPut: drummerAnim.put,
        drummerAnimGet: drummerAnim.get,
        sprinterAnimPut: sprinterAnim.put,
        sprinterAnimGet: sprinterAnim.get,
        wasdXAnimPut: wasdXAnim.put,
        wasdXAnimGet: wasdXAnim.get,
        wasdYAnimPut: wasdYAnim.put,
        wasdYAnimGet: wasdYAnim.get,
        putShapesOnCanvas: {
            earlyInputType: atom,
            beh: behEventfulTarget( { onUpdate:
                function ( maybeShapes ) {
                
                latestShapes = maybeShapes === null ? [] : _.arrMap(
                    _.arrMap( maybeShapes.val, function ( shape ) {
                        return JSON.parse( shape );
                    } ).sort( function ( a, b ) {
                        // Sort the shapes by z-index.
                        // TODO: See what we should do if two shapes
                        // have the same z-index.
                        return a[ 0 ] - b[ 0 ];
                    } ),
                    function ( shape ) {
                        // Take off the z-index information.
                        return shape[ 1 ];
                    }
                );
                
                if ( !drawNecessary )
                    requestAnimationFrame( draw );
                drawNecessary = true;
            } } )
        }
    }, function ( $, d, v, addAgents ) {
        var a = v.appActivity.v;
        function from1( a, expr ) {
            return $.fst( typeOne(), $.times( a, expr ) );
        }
        function usef( func, expr ) {
            return $.useBeh( behFmap( func ), expr );
        }
        function jzipTimesArr( arr ) {
            return usef(
                function ( list ) {
                    return JSON.stringify( _.acc( function ( y ) {
                        for (
                            ; _.likeArray( list ); list = list[ 1 ] )
                            y( JSON.parse( list[ 0 ] ) );
                        y( JSON.parse( list ) );
                    } ) );
                },
                _.arrFoldr(
                    _.arrCut( arr, 0, arr.length - 1 ),
                    arr[ arr.length - 1 ],
                    function ( a, b ) {
                        return $.zipTimes( a, b );
                    }
                )
            );
        }
        function jzipTimes( var_args ) {
            return jzipTimesArr( arguments );
        }
        function usejf( func, var_args ) {
            return usef( function ( input ) {
                return JSON.stringify(
                    func.apply( {}, JSON.parse( input ) ) );
            }, jzipTimesArr( _.arrCut( arguments, 1 ) ) );
        }
        function dk( val, activity ) {
            // The name "dk" stands for "derived constant."
            return usef( _.kfn( val ), activity );
        }
        function k( val ) {
            // The name "k" stands for "constant."
            return dk( val, a );
        }
        function djk( val, activity ) {
            // The name "djk" stands for "derived JSON constant."
            return dk( JSON.stringify( val ), activity );
        }
        function jk( val ) {
            // The name "jk" stands for "JSON constant."
            return djk( val, a );
        }
        function addVoidAgents( var_args ) {
            addAgents.apply( {},
                _.arrMap( arguments, function ( expr ) {
                    // TODO: Stop hardcoding d.e02 here. This 2 should
                    // always be whatever the last delay index is.
                    return d.e02( from1( a, expr ) );
                } ) );
        }
        function jif( condition, then, opt_els ) {
            return $.letPlus(
                $.useBeh( behSplit(), usef( function ( condition ) {
                    return JSON.parse( condition ) ?
                        [ "<", [] ] : [ ">", [] ];
                }, condition ) ),
                typePlus( atom, atom ),
                // NOTE: It's interesting that we actually have to
                // thread the activity of these branches through our
                // computation in order to mask the side effects, but
                // it makes sense.
                "appActivity", then,
                "appActivity", opt_els !== void 0 ? opt_els : $.one()
            );
        }
        function allAdd( increment, cooldownMillis ) {
            return ruleRangeAdd(
                -0x80000000 - Math.min( 0, increment ),
                0x7FFFFFFF - Math.max( 0, increment ),
                increment,
                cooldownMillis );
        }
        addVoidAgents(
            $.letPlus(
                $.useBeh( behSplit(), usef( function ( keys ) {
                    return JSON.parse( keys ) === null ?
                        [ "<", [] ] : [ ">", keys ];
                }, v.volatileKeyboard.c0( a ) ) ),
                typePlus( atom, atom ),
                "noKeys", $.one(),
                "keys", v.stableKeyboardAnimPut.c0( usef(
                    function ( keys ) {
                    
                    if ( JSON.parse( keys ) === null )
                        throw new Error();
                    return [ "set", keys ];
                }, $.va( "keys" ) ) )
            ),
            // TODO: Figure out why this can't replace the above
            // letPlus. Somehow it gets to the "throw new Error();"
            // line every time. Is it because the two uses of
            // volatilekeyboard set up independent listeners?
//            jif(
//                usejf( function ( keys ) {
//                    return keys !== null;
//                }, v.volatileKeyboard.c0( a ) ),
//                v.stableKeyboardAnimPut.c0( usef( function ( keys ) {
//                    if ( keys === "null" )
//                        throw new Error();
//                    return [ "set", keys ];
//                }, v.volatileKeyboard.c0( a ) ) )
//            ),
            v.putShapesOnCanvas.c0( v.shapesDeMonGet.c0( a ) ),
            
            v.heroKineticsAnimPut.c0( usef( function ( forces ) {
                return [ "applyForces", JSON.stringify(
                    _.arrMap( forces, function ( force ) {
                        return JSON.parse( force );
                    } ) ) ];
            }, v.heroForcesDeMonGet.c0( a ) ) ),
            
            // NOTE: If the hero ever moves faster than one hero
            // radius per frame, it can move through solid objects.
            // Hence, we only apply this acceleration if the hero is
            // slow enough.
            //
            // TODO: Right now we have to delay the gravity force
            // since we want it to depend on heroKineticsAnimGet,
            // which in turn depends on the forces being applied,
            // which depends on whether we apply the gravity force,
            // and so on. See if we can break this cycle another way.
            // Perhaps we should handle a max speed inside the stepper
            // itself, so that it automatically ignores excess
            // acceleration.
            //
            jif(
                usejf( function ( kinetics ) {
                    // TODO: Extract the magic number 30 into a more
                    // global config location.
                    var fps = 30;
                    var dtMillis = 1000 / fps;
                    // TODO: Extract the magic number 0.4 into a more
                    // global config location.
                    return kinetics.vy * dtMillis <
                        heroNaturalH * 0.4;
                }, v.heroKineticsAnimGet.c0( a ) ),
                // TODO: See if we really want to use floating-point
                // accelerations like this. This is a speed of 0.0001
                // distance units per millisecond per millisecond,
                // i.e. a speed of 100 distance units per second per
                // second.
                v.heroForcesDeMonPut.c2(
                    d.e02( jk( [ "accel", 0, 0.0001 ] ) ) )
            ),
            
            v.heroForcesDeMonPut.c0(
                jk( [ "solid", 0, 100, 200, 200 ] ) ),
            
            // TODO: Right now we have to delay the jump force since
            // we want it to depend on heroKineticsAnimGet, which in
            // turn depends on the forces being applied, which depends
            // on whether we apply the jump force, and so on. See if
            // we can break this cycle another way. Perhaps we should
            // just check jumpPropelRemainingMillis as part of the
            // heroKineticsAnim stepper and avoid delay altogether.
            jif(
                usejf(
                    function ( keys, kinetics ) {
                        var keysObj = {};
                        _.arrEach( keys, function ( key ) {
                            keysObj[ key ] = true;
                        } );
                        return !!keysObj[ KEYS.w ] &&
                            0 < kinetics.jumpPropelRemainingMillis;
                    },
                    v.stableKeyboard.c0( a ),
                    v.heroKineticsAnimGet.c0( a ) ),
                v.heroForcesDeMonPut.c2(
                    d.e02( jk( [ "jump", -0.1, -0.05 ] ) ) )
            ),
            
            v.showShape.c0( usejf( function ( animState ) {
                return [ 0,
                    [ "rect", "#FFFF00",
                        [ "viewport",
                            100 + animState.centerX -
                                (animState.squishW / 2),
                            100 + animState.centerY -
                                (animState.squishH / 2) ],
                        animState.squishW,
                        animState.squishH ] ];
            }, v.heroKineticsAnimGet.c0( a ) ) ),
            
            v.showShape.c1( usejf( function ( mouse ) {
                if ( mouse === null )
                    mouse = [ 0, 0 ];
                return [ 0,
                    [ "rect", "#FFFFFF",
                        [ "viewport",
                            mouse[ 0 ] - 10, mouse[ 1 ] - 10 ],
                        20, 20 ] ];
            }, d.e01( v.mouse.c0( a ) ) ) ),
            
            v.showShape.c0(
                jk(
                    [ 0,
                        [ "rect", "#FFFFFF",
                            [ "viewport", 130, 180 ],
                            5, 5 ] ] ) ),
            
            v.drummerAnimPut.c0( k( ruleReplace( 0, 1, 300 ) ) ),
            v.drummerAnimPut.c0( k( ruleReplace( 1, 2, 300 ) ) ),
            v.drummerAnimPut.c0( k( ruleReplace( 2, 0, 300 ) ) ),
            v.showShape.c0( usejf( function ( animState ) {
                return [ 0,
                    [ "rect", "#FFFFFF",
                        [ "viewport", 80 + (animState * 20), 150 ],
                        5, 5 ] ];
            }, v.drummerAnimGet.c0( a ) ) ),
            
            $.letPlus(
                $.useBeh( behSplit(), usef( function ( animState ) {
                    return JSON.parse( animState ) === 0 ?
                        [ "<", [] ] : [ ">", [] ];
                }, v.drummerAnimGet.c0( a ) ) ),
                typePlus( atom, atom ),
                // NOTE: It's interesting that we actually have to
                // thread the activity of these branches through our
                // computation in order to mask the side effects, but
                // it makes sense.
                "then", v.showShape.c0(
                    djk(
                        [ 0,
                            [ "rect", "#FFFFFF",
                                [ "viewport", 40, 150 ],
                                5, 5 ] ],
                        $.va( "then" ) ) ),
                "else", v.showShape.c0(
                    djk(
                        [ 0,
                            [ "rect", "#FFFFFF",
                                [ "viewport", 50, 150 ],
                                5, 5 ] ],
                        $.va( "else" ) ) )
            ),
            
            v.sprinterAnimPut.c0( usef( function ( animState ) {
                return allAdd(
                    3 * (JSON.parse( animState ) - 1), 50 );
            }, v.drummerAnimGet.c0( a ) ) ),
            v.showShape.c0( usejf( function ( animState ) {
                return [ 0,
                    [ "rect", "#FFFFFF",
                        [ "viewport", 80 + animState, 130 ],
                        5, 5 ] ];
            }, v.sprinterAnimGet.c0( a ) ) ),
            
            v.wasdXAnimPut.c0( usef( function ( keys ) {
                var keysObj = {};
                _.arrEach( JSON.parse( keys ), function ( key ) {
                    keysObj[ key ] = true;
                } );
                var dir = (keysObj[ KEYS.d ] ? 1 : 0) -
                    (keysObj[ KEYS.a ] ? 1 : 0);
                if ( dir === -1 )
                    return allAdd( -3, 50 );
                else if ( dir === 1 )
                    return allAdd( 3, 50 );
                else
                    return [];
                // TODO: Instead of returning the invalid rule [],
                // don't apply any rule at all.
            }, v.stableKeyboard.c0( a ) ) ),
            v.wasdYAnimPut.c0( usef( function ( keys ) {
                var keysObj = {};
                _.arrEach( JSON.parse( keys ), function ( key ) {
                    keysObj[ key ] = true;
                } );
                var dir = (keysObj[ KEYS.s ] ? 1 : 0) -
                    (keysObj[ KEYS.w ] ? 1 : 0);
                if ( dir === -1 )
                    return allAdd( -3, 50 );
                else if ( dir === 1 )
                    return allAdd( 3, 50 );
                else
                    return [];
                // TODO: Instead of returning the invalid rule [],
                // don't apply any rule at all.
            }, v.stableKeyboard.c0( a ) ) ),
            v.showShape.c0( usejf( function ( animState ) {
                return [ 0,
                    [ "rect", "#FFFFFF",
                        [ "viewport",
                            80 + animState[ 0 ],
                            200 + animState[ 1 ] ],
                        5, 5 ] ];
            }, jzipTimes(
                v.wasdXAnimGet.c0( a ), v.wasdYAnimGet.c0( a ) ) ) ),
            
            $.one()
        );
    } );
    
    _.appendDom( _.el( "demo" ), canvas );
} } );
</script>
</head>
<body>
<h3>Platformer</h3>
<div id="demo"></div>
<p>Use the w key to jump. Try holding the key for different periods of
  time.</p>
<p>TODO: Actually make this into a platform game.</p>
<p>TODO: Put a better description here.</p>
</body>
</html>
