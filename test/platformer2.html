<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<title>Platformer using Underreact</title>
<!-- platformer.html (part of Underreact) -->
<!--

The copyright and license information below applies to this file as an
independent work. Other files commonly used or bundled with this one
may have different authors and different posted licenses.

-->
<!--

Copyright (c) 2012, Ross Angle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-->
<meta name="viewport"
    content="initial-scale = 1.0, maximum-scale = 1.0" />
<style type="text/css">
</style>

<script type="text/javascript" src="../lib/lathe.js"></script>

<script type="text/javascript">"use strict";
var _ = rocketnia.lathe;
</script>
<script type="text/javascript" src="../src/underreact-async.js"
    ></script>
<script type="text/javascript" src="../src/underreact-behaviors.js"
    ></script>
<script type="text/javascript" src="../src/underreact-lambda.js"
    ></script>
<script type="text/javascript" src="tests.js"></script>
<script type="text/javascript">"use strict";
_.appendDom( window, { load: function () {
    
    var atom = typeAtom( 0, null );
    
    // TODO: Use something like this for Lathe.js's _.defer(). Right
    // here we're non-modularly hacking it in (or rather we aren't,
    // since right now the crucial line is commented out).
    //
    // TODO: Actually, see if we need this at all. This code is
    // commented out, and it doesn't seem to make a difference.
    //
    // TODO: Test postMessage on various browsers.
    //
    var customDeferredFuncs = [];
    var customDefer = function ( deferredFunc ) {
        customDeferredFuncs.push( deferredFunc );
        postMessage( "customDefer", "*" );
    };
    _.appendDom( window, { message: function ( e ) {
        if ( e.source === window
            && e.data === "customDefer"
            && customDeferredFuncs.length !== 0 )
            customDeferredFuncs.pop()();
    } } );
//    _.defer = customDefer;
    var customDefer = _.defer;
    
    var w = 200, h = 200;
    var canvas = _.dom( "canvas", { width: "" + w, height: "" + h } );
    var ctx = canvas.getContext( "2d" );
    
    function elPos( el ) {
        // NOTE: This is loosely taken from an example at
        // <http://www.kirupa.com/html5/get_element_position_using_javascript.htm>.
        var x = 0, y = 0;
        for ( var e = el; e !== null; e = e.offsetParent ) {
            x += e.offsetLeft - e.scrollLeft + e.clientLeft;
            y += e.offsetTop - e.scrollTop + e.clientTop;
        }
        return { x: x, y: y };
    }
    
    // TODO: Test requestAnimationFrame on various browsers. Some
    // important browsers may not support it or may only support it
    // under a prefix.
    var latestShapes = [];
    var drawNecessary = true;
    function draw() {
        if ( !drawNecessary )
            return;
        
        drawNecessary = false;
        
        ctx.fillStyle = "#000000";
        ctx.fillRect( 0, 0, w, h );
        var cPos = elPos( canvas );
        _.arrEach( latestShapes, function ( shape ) {
            function parseCoord( coord ) {
                if ( coord[ 0 ] === "viewport" ) {
                    return {
                        x: coord[ 1 ] - cPos.x,
                        y: coord[ 2 ] - cPos.y
                    };
                } else if ( coord[ 0 ] === "canvas" ) {
                    return { x: coord[ 1 ], y: coord[ 2 ] };
                } else {
                    throw new Error();
                }
            }
            if ( shape[ 0 ] === "rect" ) {
                ctx.fillStyle = "" + shape[ 1 ];
                var tl = parseCoord( shape[ 2 ] );
                ctx.fillRect( tl.x, tl.y, shape[ 3 ], shape[ 4 ] );
            } else {
                throw new Error();
            }
        } );
    }
    requestAnimationFrame( draw );
    
    function sortByPrim( a, b ) {
        return a < b ? -1 : b < a ? 1 : 0;
    }
    function sortByMap( func, opt_thenSort ) {
        if ( opt_thenSort === void 0 )
            opt_thenSort = sortByPrim;
        return function ( a, b ) {
            return opt_thenSort( func( a ), func( b ) );
        };
    }
    function sortByTrials( sorters ) {
        // TODO: See if this will come in handy.
        return function ( a, b ) {
            var anyResult = _.arrAny( sorters, function ( sorter ) {
                var thisResult = sorter( a, b );
                if ( thisResult === 0 )
                    return false;
                return { val: thisResult };
            } );
            return anyResult ? anyResult.val : 0;
        };
    }
    
    function makeDeMonCaps() {
        var resource = behDemandMonitor( customDefer );
        return {
            put: {
                earlyInputType: atom,
                beh: resource.demander
            },
            get: {
                earlyInputType: atom,
                beh: resource.monitor
            }
        };
    }
    
    function animatedStateResourceToCaps( resource ) {
        return {
            put: {
                earlyInputType: atom,
                beh: resource.demander
            },
            get: {
                earlyInputType: atom,
                beh: resource.monitor
            }
        };
    }
    function makeAnimatedStateCaps(
        initialState, compareStates, transitions ) {
        
        return animatedStateResourceToCaps( behAnimatedState(
            customDefer, initialState, compareStates, transitions ) );
    }
    
    function makeInt32AnimatedStateCaps() {
        
        // We validate each entry and just filter it out if it's
        // invalid. Specifically, it must be one of the following:
        //
        // - A four-element Array containing the string "replace", a
        //   signed 32-bit int, a signed 32-bit int, and a positive
        //   integer duration in milliseconds.
        //
        // - A five-element Array containing the string "rangeAdd", a
        //   signed 32-bit int lower bound (inclusive), a signed
        //   32-bit int upper bound (inclusive), a signed 32-bit int
        //   which can be added to any int in that range without
        //   overflowing, and a positive integer duration in
        //   milliseconds. The lower bound must be less than or equal
        //   to the upper bound.
        
        // TODO: Find a more elegant approach using modulo arithmetic.
        
        function isState( x ) {
            return x === ~~x;
        }
        function isIncrement( x ) {
            return x === ~~x;
        }
        function isIntDuration( x ) {
            return isValidDuration( x ) && x % 1 === 0;
        }
        
        return makeAnimatedStateCaps( 0, sortByPrim, {
            replace: function ( rule ) {
                rule = JSON.parse( rule );
                if ( !(true
                    && _.likeArray( rule )
                    && rule.length === 3
                    && isState( rule[ 0 ] )
                    && isState( rule[ 1 ] )
                    && isIntDuration( rule[ 2 ] )
                ) )
                    return [];
                return [ function ( oldVal ) {
                    if ( oldVal !== rule[ 0 ] )
                        return null;
                    return {
                        newVal: rule[ 1 ],
                        cooldownMillis: rule[ 2 ]
                    };
                } ];
            },
            rangeAdd: function ( rule ) {
                rule = JSON.parse( rule );
                if ( !(true
                    && _.likeArray( rule )
                    && rule.length === 4
                    && isState( rule[ 0 ] )
                    && isState( rule[ 1 ] )
                    && rule[ 0 ] <= rule[ 1 ]
                    && isIncrement( rule[ 2 ] )
                    && isState( rule[ 0 ] + rule[ 2 ] )
                    && isState( rule[ 1 ] + rule[ 2 ] )
                    && isIntDuration( rule[ 3 ] )
                ) )
                    return [];
                return [ function ( oldVal ) {
                    if ( !(rule[ 0 ] <= oldVal
                        && oldVal <= rule[ 1 ]) )
                        return null;
                    return {
                        newVal: oldVal + rule[ 2 ],
                        cooldownMillis: rule[ 3 ]
                    };
                } ];
            }
        } );
    }
    function ruleReplace( oldVal, newVal, cooldownMillis ) {
        return [ "replace",
            JSON.stringify( [ oldVal, newVal, cooldownMillis ] ) ];
    }
    function ruleRangeAdd( oldMin, oldMax, inc, cooldownMillis ) {
        return [ "rangeAdd", JSON.stringify(
            [ oldMin, oldMax, inc, cooldownMillis ] ) ];
    }
    
    var stableKeyboardAnim =
        makeAnimatedStateCaps( [], sortByTrials(), {
        
        set: function ( newVal ) {
            newVal = JSON.parse( newVal );
            return [ function ( oldVal ) {
                // TODO: Figure out what frame rate would be
                // appropriate for the keyboard input. Perhaps we
                // should just make a new state resource that just
                // prolongs a state until the next valid replacement
                // comes along. Then it'll effectively be this with a
                // cooldown of 0, even though we can't actually use 0
                // here without entering an infinite loop.
                return { cooldownMillis: ~~(1000 / 30),
                    newVal: newVal };
            } ];
        }
    } );
    var shapesDeMon = makeDeMonCaps();
    var heroForcesDeMon = makeDeMonCaps();
    var heroVolitionAnim = makeAnimatedStateCaps(
        {
            precedence: 0,
            goingLeft: false,
            goingRight: false,
            jumping: false,
            // TODO: See if this should really be part of the
            // heroVolitionAnim state.
            ignoringJumps: false
        },
        sortByMap( function ( state ) {
            return state.precedence;
        } ),
        {
            controlAndEnv: function ( rule ) {
                rule = JSON.parse( rule );
                var controlLeft = rule[ 0 ];
                var controlRight = rule[ 1 ];
                var controlJump = rule[ 2 ];
                var envStanding = rule[ 3 ];
                var envJumpPropelled = rule[ 4 ];
                return [ function ( oldVal ) {
                    var jumping = controlJump &&
                        ((envStanding && !oldVal.ignoringJumps) ||
                            (envJumpPropelled && oldVal.jumping));
                    return { cooldownMillis: ~~(1000 / 30), newVal: {
                        precedence: 0,
                        goingLeft: controlLeft && !controlRight,
                        goingRight: controlRight && !controlLeft,
                        jumping: jumping,
                        ignoringJumps: !envStanding ||
                            (controlJump && oldVal.ignoringJumps)
                    } };
                } ];
            }
        } );
    // TODO: Extract some of these magic numbers into a more global
    // config location.
    var defaultJumpPropelMillis = 500;
    var heroNaturalW = 20;
    var heroNaturalH = 20;
    var heroKineticsAnim = makeAnimatedStateCaps(
        {
            precedence: 0,
            vx: 0,
            vy: 0,
            
            // NOTE: If the hero ever moves faster than one hero
            // radius per frame, it can move through solid objects.
            // Because of this, we always adjust after acceleration so
            // the hero's velocity is slow enough.
            topSpeedX: heroNaturalW * 0.4,
            topSpeedY: heroNaturalH * 0.4,
            
            centerX: 0,
            centerY: 0,
            naturalW: heroNaturalW,
            naturalH: heroNaturalH,
            squishW: heroNaturalW,
            squishH: heroNaturalH,
            standing: 0,
            jumpPropelRemainingMillis: defaultJumpPropelMillis
        },
        sortByMap( function ( state ) {
            return state.precedence;
        } ),
        {
            applyForces: function ( rule ) {
                
                var forces = _.arrMap( JSON.parse( rule ),
                    function ( force ) {
                    
                    if ( force[ 0 ] === "solid" )
                        return {
                            type: "solid",
                            
                            // TODO: Figure out which of these groups
                            // to actually use in the Array
                            // representation of this force.
                            
                            tlx: force[ 1 ],
                            tly: force[ 2 ],
                            w: force[ 3 ],
                            h: force[ 4 ],
                            
                            minX: force[ 1 ],
                            minY: force[ 2 ],
                            maxX: force[ 1 ] + force[ 3 ],
                            maxY: force[ 2 ] + force[ 4 ]
                        };
                    else if ( force[ 0 ] === "accel" )
                        return {
                            type: "accel",
                            // NOTE: The "forceName" field just exists
                            // so we can apply two cumulative forces
                            // whose contents are otherwise identical.
                            forceName: force[ 1 ],
                            // TODO: Clarify that these are measured
                            // in distance units per millisecond per
                            // millisecond.
                            x: force[ 2 ],
                            y: force[ 3 ]
                        };
                    else if ( force[ 0 ] === "move" )
                        return {
                            type: "move",
                            // NOTE: The "forceName" field just exists
                            // so we can apply two cumulative forces
                            // whose contents are otherwise identical.
                            forceName: force[ 1 ],
                            // TODO: Clarify that these are measured
                            // in distance units per millisecond.
                            vx: force[ 2 ],
                            vy: force[ 3 ]
                        };
                    else if ( force[ 0 ] === "jump" )
                        return {
                            type: "jump",
                            // TODO: Clarify that these are measured
                            // in distance units per millisecond.
                            vyDuring: force[ 1 ],
                            vyAfterward: force[ 2 ]
                        };
                    else
                        throw new Error();
                } );
                
                var ax = 0;
                var ay = 0;
                _.arrEach( forces, function ( force ) {
                    if ( force.type !== "accel" )
                        return;
                    ax += force.x;
                    ay += force.y;
                } );
                
                var movex = 0;
                var movey = 0;
                _.arrEach( forces, function ( force ) {
                    if ( force.type !== "move" )
                        return;
                    movex += force.x;
                    movey += force.y;
                } );
                
                var tryingToJump = false;
                var jumpvyDuring = 1 / 0;
                var jumpvyAfterward = 1 / 0;
                _.arrEach( forces, function ( force ) {
                    if ( force.type !== "jump" )
                        return;
                    tryingToJump = true;
                    // TODO: Right now these are minimum'd separately.
                    // See if we should somehow compare them as
                    // inseparable pairs.
                    jumpvyDuring = Math.min( jumpvyDuring,
                        force.vyDuring );
                    jumpvyAfterward = Math.min( jumpvyAfterward,
                        force.vyAfterward );
                } );
                
                return [ function ( ov ) {
                    
                    // TODO: Extract the magic number 30 into a more
                    // global config location.
                    var fps = 30;
                    var dtMillis = 1000 / fps;
                    
                    var jumping = tryingToJump &&
                        0 < ov.jumpPropelRemainingMillis;
                    
                    function clamp( min, val, max ) {
                        return Math.max( min, Math.min( val, max ) );
                    }
                    
                    var appliedMoveX = movex;
                    var appliedMoveY = movey;
                    var desiredfvx = clamp( -ov.topSpeedX,
                        ov.vx + appliedMoveX + ax * dtMillis,
                        ov.topSpeedX );
                    var desiredfvy = clamp( -ov.topSpeedY,
                        ov.vy + appliedMoveY + ay * dtMillis,
                        ov.topSpeedY );
                    var desiredmidvx = (ov.vx + desiredfvx) / 2;
                    var desiredmidvy = (ov.vy + desiredfvy) / 2;
                    var vyIsBasedOnJump =
                        jumping && jumpvyDuring < desiredmidvy;
                    if ( vyIsBasedOnJump )
                        desiredmidvy = jumpvyDuring;
                    var desiredcx =
                        ov.centerX + (desiredmidvx * dtMillis);
                    var desiredcy =
                        ov.centerY + (desiredmidvy * dtMillis);
                    
                    var availableRect = {
                        minX: -1 / 0,
                        maxX: 1 / 0,
                        minY: -1 / 0,
                        maxY: 1 / 0
                    };
                    _.arrEach( forces, function ( force ) {
                        if ( force.type !== "solid" )
                            return;
                        if ( desiredcx < force.minX )
                            availableRect.maxX = Math.min(
                                availableRect.maxX, force.minX );
                        if ( force.maxX < desiredcx )
                            availableRect.minX = Math.max(
                                availableRect.minX, force.maxX );
                        if ( desiredcy < force.minY )
                            availableRect.maxY = Math.min(
                                availableRect.maxY, force.minY );
                        if ( force.maxY < desiredcy )
                            availableRect.minY = Math.max(
                                availableRect.minY, force.maxY );
                    } );
                    
                    
                    var finalRect = {
                        minX: desiredcx - (ov.naturalW / 2),
                        maxX: desiredcx + (ov.naturalW / 2),
                        minY: desiredcy - (ov.naturalH / 2),
                        maxY: desiredcy + (ov.naturalH / 2)
                    };
                    
                    var vyMinSolid = -1 / 0;
                    var vyMaxSolid = 1 / 0;
                    if ( availableRect.maxY - availableRect.minY <
                        ov.naturalH ) {
                        
                        finalRect.minY = availableRect.minY;
                        finalRect.maxY = availableRect.maxY;
                        
                    } else if (
                        availableRect.maxY < finalRect.maxY ) {
                        
                        var diff =
                            availableRect.maxY - finalRect.maxY;
                        finalRect.minY += diff;
                        finalRect.maxY += diff;
                        
                    } else if (
                        finalRect.minY < availableRect.minY ) {
                        
                        var diff =
                            availableRect.minY - finalRect.minY;
                        finalRect.minY += diff;
                        finalRect.maxY += diff;
                    }
                    
                    if ( availableRect.maxX - availableRect.minX <
                        ov.naturalW ) {
                        
                        finalRect.minX = availableRect.minX;
                        finalRect.maxX = availableRect.maxX;
                        
                    } else if (
                        availableRect.maxX < finalRect.maxX ) {
                        
                        var diff =
                            availableRect.maxX - finalRect.maxX;
                        finalRect.minX += diff;
                        finalRect.maxX += diff;
                        
                    } else if (
                        finalRect.minX < availableRect.minX ) {
                        
                        var diff =
                            availableRect.minX - finalRect.minX;
                        finalRect.minX += diff;
                        finalRect.maxX += diff;
                    }
                    
                    
                    var actualcx =
                        (finalRect.minX + finalRect.maxX) / 2;
                    var actualcy =
                        (finalRect.minY + finalRect.maxY) / 2;
                    var actualmidvx =
                        (actualcx - ov.centerX) / dtMillis;
                    var actualmidvy =
                        (actualcy - ov.centerY) / dtMillis;
                    
                    // NOTE: We clamp these toward zero, rather than
                    // letting the entity bounce off walls. Even if we
                    // didn't do this clamping, the entity's bouncing
                    // would be erratic. It would not bounce if it
                    // collided at exactly the same time as a frame
                    // step, and it would bounce at 100% its original
                    // speed if it collided halfway between frames.
                    var actualfvx = ov.vx + (actualmidvx - ov.vx) * 2;
                    if ( (0 < ov.vx) !== (0 < actualfvx) )
                        actualfvx = 0;
                    if ( (0 < movex) ===
                        (actualfvx + movex < desiredfvx) )
                        actualfvx -= movex;
                    var actualfvy = ov.vy + (actualmidvy - ov.vy) * 2;
                    if ( (0 < ov.vy) !== (0 < actualfvy) )
                        actualfvy = 0;
                    
                    if ( vyIsBasedOnJump )
                        actualfvy = jumpvyAfterward;
                    
                    
                    var standing =
                        finalRect.maxY === availableRect.maxY;
                    
                    
                    return { cooldownMillis: ~~dtMillis, newVal: {
                        precedence: 0,
                        vx: actualfvx,
                        vy: actualfvy,
                        topSpeedX: ov.topSpeedX,
                        topSpeedY: ov.topSpeedY,
                        centerX: actualcx,
                        centerY: actualcy,
                        naturalW: ov.naturalW,
                        naturalH: ov.naturalH,
                        squishW: finalRect.maxX - finalRect.minX,
                        squishH: finalRect.maxY - finalRect.minY,
                        standing: standing,
                        jumpPropelRemainingMillis:
                            jumping ?
                                Math.max( 0,
                                    ov.jumpPropelRemainingMillis -
                                        dtMillis ) :
                            standing ? defaultJumpPropelMillis :
                            0
                    } };
                } ];
            }
        } );
    var drummerAnim = makeInt32AnimatedStateCaps();
    var sprinterAnim = makeInt32AnimatedStateCaps();
    var wasdXAnim = makeInt32AnimatedStateCaps();
    var wasdYAnim = makeInt32AnimatedStateCaps();
    
    var KEYS = {
        a: 65,
        d: 68,
        s: 83,
        w: 87
    };
    
    runLambdaLangConvenient( [ 1, 49 ], {
        volatileKeyboard: {
            earlyInputType: atom,
            beh: behEventfulSource( {
                apologyVal: JSON.stringify( null ),
                listenOnUpdate: function ( listener ) {
                    var keysObj = {};
                    var keysArr = [];
                    
                    function keyCode( event ) {
                        return event.which ||
                            event.keyCode;  // IE
                    }
                    
                    _.appendDom( window, { keydown: function ( e ) {
                        var key = keyCode( e );
                        if ( keysObj[ key ] )
                            return;
                        keysObj[ key ] = true;
                        keysArr.push( key );
                        listener( JSON.stringify( keysArr ) );
                    } } );
                    _.appendDom( window, { keyup: function ( e ) {
                        var key = keyCode( e );
                        if ( !keysObj[ key ] )
                            return;
                        delete keysObj[ key ];
                        keysArr = _.arrKeep( keysArr, function ( k ) {
                            return k !== key;
                        } );
                        listener( JSON.stringify( keysArr ) );
                    } } );
                },
                intervalMillis: 1,
                stabilityMillis: 6
            } )
        },
        mouse: {
            earlyInputType: atom,
            beh: behMouseQuery( {
                intervalMillis: 1,
                // NOTE: This setting makes the biggest difference for
                // the responsiveness of the interface. At 10 ms, it's
                // noticeably laggier than canvas-control-group.html.
                // At 4 ms, it noticeably flickers due to all the gaps
                // of inactivity.
                // TODO: Since this is likely to have a slightly
                // different optimal value depending on the 
                stabilityMillis: 6
            } )
        },
        stableKeyboardAnimPut: stableKeyboardAnim.put,
        stableKeyboard: stableKeyboardAnim.get,
        showShape: shapesDeMon.put,
        shapesDeMonGet: shapesDeMon.get,
        heroForcesDeMonPut: heroForcesDeMon.put,
        heroForcesDeMonGet: heroForcesDeMon.get,
        heroVolitionAnimPut: heroVolitionAnim.put,
        heroVolitionAnimGet: heroVolitionAnim.get,
        heroKineticsAnimPut: heroKineticsAnim.put,
        heroKineticsAnimGet: heroKineticsAnim.get,
        drummerAnimPut: drummerAnim.put,
        drummerAnimGet: drummerAnim.get,
        sprinterAnimPut: sprinterAnim.put,
        sprinterAnimGet: sprinterAnim.get,
        wasdXAnimPut: wasdXAnim.put,
        wasdXAnimGet: wasdXAnim.get,
        wasdYAnimPut: wasdYAnim.put,
        wasdYAnimGet: wasdYAnim.get,
        putShapesOnCanvas: {
            earlyInputType: atom,
            beh: behEventfulTarget( { onUpdate:
                function ( maybeShapes ) {
                
                latestShapes = maybeShapes === null ? [] : _.arrMap(
                    _.arrMap( maybeShapes.val, function ( shape ) {
                        return JSON.parse( shape );
                    } ).sort( function ( a, b ) {
                        // Sort the shapes by z-index.
                        // TODO: See what we should do if two shapes
                        // have the same z-index.
                        return a[ 0 ] - b[ 0 ];
                    } ),
                    function ( shape ) {
                        // Take off the z-index information.
                        return shape[ 1 ];
                    }
                );
                
                if ( !drawNecessary )
                    requestAnimationFrame( draw );
                drawNecessary = true;
            } } )
        }
    }, function ( $, d, v, addAgents ) {
        var a = v.appActivity.v;
        function from1( a, expr ) {
            return $.fst( typeOne(), $.times( a, expr ) );
        }
        function plainUsef( func, expr ) {
            return $.useBeh( behFmap( func ), expr );
        }
        function zipTimesArr( arr ) {
            var n = arr.length;
            return plainUsef(
                function ( list ) {
                    return _.acc( function ( y ) {
                        for ( var i = 0; i < n - 1; i++ ) {
                            y( list[ 0 ] );
                            list = list[ 1 ];
                        }
                        y( list );
                    } );
                },
                _.arrFoldr(
                    _.arrCut( arr, 0, arr.length - 1 ),
                    arr[ arr.length - 1 ],
                    function ( a, b ) {
                        return $.zipTimes( a, b );
                    }
                )
            );
        }
        function jzipTimesArr( arr ) {
            var n = arr.length;
            return plainUsef(
                function ( list ) {
                    return JSON.stringify( _.acc( function ( y ) {
                        for ( var i = 0; i < n - 1; i++ ) {
                            y( JSON.parse( list[ 0 ] ) );
                            list = list[ 1 ];
                        }
                        y( JSON.parse( list ) );
                    } ) );
                },
                _.arrFoldr(
                    _.arrCut( arr, 0, arr.length - 1 ),
                    arr[ arr.length - 1 ],
                    function ( a, b ) {
                        return $.zipTimes( a, b );
                    }
                )
            );
        }
        function usef( func, var_args ) {
            return plainUsef( function ( input ) {
                return func.apply( {}, input );
            }, zipTimesArr( _.arrCut( arguments, 1 ) ) );
        }
        function jzipTimes( var_args ) {
            return jzipTimesArr( arguments );
        }
        function usejf( func, var_args ) {
            return plainUsef( function ( input ) {
                return JSON.stringify(
                    func.apply( {}, JSON.parse( input ) ) );
            }, jzipTimesArr( _.arrCut( arguments, 1 ) ) );
        }
        function dk( val, activity ) {
            // The name "dk" stands for "derived constant."
            return plainUsef( _.kfn( val ), activity );
        }
        function k( val ) {
            // The name "k" stands for "constant."
            return dk( val, a );
        }
        function djk( val, activity ) {
            // The name "djk" stands for "derived JSON constant."
            return dk( JSON.stringify( val ), activity );
        }
        function jk( val ) {
            // The name "jk" stands for "JSON constant."
            return djk( val, a );
        }
        function addVoidAgents( var_args ) {
            addAgents.apply( {},
                _.arrMap( arguments, function ( expr ) {
                    // TODO: Stop hardcoding d.e02 here. This 2 should
                    // always be whatever the last delay index is.
                    return d.e02( from1( a, expr ) );
                } ) );
        }
        function jif( condition, then, opt_els ) {
            return $.letPlus(
                $.useBeh( behSplit(), usef( function ( condition ) {
                    return JSON.parse( condition ) ?
                        [ "<", [] ] : [ ">", [] ];
                }, condition ) ),
                typePlus( atom, atom ),
                // NOTE: It's interesting that we actually have to
                // thread the activity of these branches through our
                // computation in order to mask the side effects, but
                // it makes sense.
                "appActivity", then,
                "appActivity", opt_els !== void 0 ? opt_els : $.one()
            );
        }
        function allAdd( increment, cooldownMillis ) {
            return ruleRangeAdd(
                -0x80000000 - Math.min( 0, increment ),
                0x7FFFFFFF - Math.max( 0, increment ),
                increment,
                cooldownMillis );
        }
        function solid( x, y, w, h ) {
            addVoidAgents(
                v.heroForcesDeMonPut.c0(
                    jk( [ "solid", x, y, w, h ] ) ),
                v.showShape.c0( jk( [ 0,
                    [ "rect", "#0000FF",
                        [ "canvas", 100 + x, 100 + y ], w, h ]
                ] ) )
            );
        }
        solid( -1 * 50, -3 * 50, 2 * 50, 2 * 50 );
        solid( -3 * 50, -1 * 50, 2 * 50, 2 * 50 );
        solid( 1 * 50, -1 * 50, 2 * 50, 2 * 50 );
        solid( -1 * 50, 1 * 50, 2 * 50, 2 * 50 );
        addVoidAgents(
            $.letPlus(
                $.useBeh( behSplit(), usef( function ( keys ) {
                    return JSON.parse( keys ) === null ?
                        [ "<", [] ] : [ ">", keys ];
                }, v.volatileKeyboard.c0( a ) ) ),
                typePlus( atom, atom ),
                "noKeys", $.one(),
                "keys", v.stableKeyboardAnimPut.c0( usef(
                    function ( keys ) {
                    
                    if ( JSON.parse( keys ) === null )
                        throw new Error();
                    return [ "set", keys ];
                }, $.va( "keys" ) ) )
            ),
            // TODO: Figure out why this can't replace the above
            // letPlus. Somehow it gets to the "throw new Error();"
            // line every time. Is it because the two uses of
            // volatilekeyboard set up independent listeners?
//            jif(
//                usejf( function ( keys ) {
//                    return keys !== null;
//                }, v.volatileKeyboard.c0( a ) ),
//                v.stableKeyboardAnimPut.c0( usef( function ( keys ) {
//                    if ( keys === "null" )
//                        throw new Error();
//                    return [ "set", keys ];
//                }, v.volatileKeyboard.c0( a ) ) )
//            ),
            v.putShapesOnCanvas.c0( v.shapesDeMonGet.c0( a ) ),
            
            v.heroKineticsAnimPut.c0( usef( function ( forces ) {
                return [ "applyForces", JSON.stringify(
                    _.arrMap( forces, function ( force ) {
                        return JSON.parse( force );
                    } ) ) ];
            }, v.heroForcesDeMonGet.c0( a ) ) ),
            
            // TODO: See if we really want to use floating-point
            // accelerations like this. This is a speed of 0.0002
            // distance units per millisecond per millisecond, i.e. a
            // speed of 200 distance units per second per second.
            v.heroForcesDeMonPut.c0(
                jk( [ "accel", "gravity", 0, 0.0002 ] ) ),
            
            v.heroVolitionAnimPut.c2( usef(
                function ( keys, env ) {
                    var keysObj = {};
                    _.arrEach( JSON.parse( keys ), function ( key ) {
                        keysObj[ key ] = true;
                    } );
                    env = JSON.parse( env );
                    
                    var controlLeft = keysObj[ KEYS.a ];
                    var controlRight = keysObj[ KEYS.d ];
                    var controlJump = keysObj[ KEYS.w ];
                    var envStanding = env.standing;
                    var envJumpPropelled =
                        0 < env.jumpPropelRemainingMillis;
                    return [ "controlAndEnv", JSON.stringify( [
                        controlLeft, controlRight, controlJump,
                        envStanding, envJumpPropelled ] ) ];
                },
                v.stableKeyboard.c2( d.e02( a ) ),
                
                // NOTE: The hero's volition is partly dependent on
                // its kinetics (and, of course, vice versa). To
                // control this feedback loop, we explicitly make the
                // volition depend on a somewhat out-of-date kinetics
                // value. This means the hero might try to jump even
                // in cases where it makes no difference, and (much
                // worse) the hero might not try to jump because it
                // doesn't know it's standing yet. (We don't want to
                // let the player hold the jump button to bounce.)
                //
                // TODO: Figure out if we can improve this.
                //
                d.e02( v.heroKineticsAnimGet.c0( a ) )
            ) ),
            
            jif(
                usejf( function ( volition ) {
                    return volition.jumping;
                }, v.heroVolitionAnimGet.c0( a ) ),
                v.heroForcesDeMonPut.c0(
                    jk( [ "jump", -0.1, -0.05 ] ) )
            ),
            
            // TODO: Give the hero horizontal friction.
            jif(
                usejf( function ( volition ) {
                    return volition.goingLeft;
                }, v.heroVolitionAnimGet.c0( a ) ),
                v.heroForcesDeMonPut.c0(
                    jk( [ "accel", "goingLeft", -0.0005, 0 ] ) )
            ),
            jif(
                usejf( function ( volition ) {
                    return volition.goingRight;
                }, v.heroVolitionAnimGet.c0( a ) ),
                v.heroForcesDeMonPut.c0(
                    jk( [ "accel", "goingRight", 0.0005, 0 ] ) )
            ),
            
            v.showShape.c0( usejf( function ( animState ) {
                return [ 0,
                    [ "rect", "#FFFF00",
                        [ "canvas",
                            100 + animState.centerX -
                                (animState.squishW / 2),
                            100 + animState.centerY -
                                (animState.squishH / 2) ],
                        animState.squishW,
                        animState.squishH ] ];
            }, v.heroKineticsAnimGet.c0( a ) ) ),
            
            v.showShape.c1( usejf( function ( mouse ) {
                if ( mouse === null )
                    mouse = [ 0, 0 ];
                return [ 0,
                    [ "rect", "#FFFFFF",
                        [ "viewport",
                            mouse[ 0 ] - 10, mouse[ 1 ] - 10 ],
                        20, 20 ] ];
            }, d.e01( v.mouse.c0( a ) ) ) ),
            
            v.showShape.c0(
                jk(
                    [ 0,
                        [ "rect", "#FFFFFF",
                            [ "viewport", 130, 180 ],
                            5, 5 ] ] ) ),
            
            v.drummerAnimPut.c0( k( ruleReplace( 0, 1, 300 ) ) ),
            v.drummerAnimPut.c0( k( ruleReplace( 1, 2, 300 ) ) ),
            v.drummerAnimPut.c0( k( ruleReplace( 2, 0, 300 ) ) ),
            v.showShape.c0( usejf( function ( animState ) {
                return [ 0,
                    [ "rect", "#FFFFFF",
                        [ "viewport", 80 + (animState * 20), 150 ],
                        5, 5 ] ];
            }, v.drummerAnimGet.c0( a ) ) ),
            
            $.letPlus(
                $.useBeh( behSplit(), usef( function ( animState ) {
                    return JSON.parse( animState ) === 0 ?
                        [ "<", [] ] : [ ">", [] ];
                }, v.drummerAnimGet.c0( a ) ) ),
                typePlus( atom, atom ),
                // NOTE: It's interesting that we actually have to
                // thread the activity of these branches through our
                // computation in order to mask the side effects, but
                // it makes sense.
                "then", v.showShape.c0(
                    djk(
                        [ 0,
                            [ "rect", "#FFFFFF",
                                [ "viewport", 40, 150 ],
                                5, 5 ] ],
                        $.va( "then" ) ) ),
                "else", v.showShape.c0(
                    djk(
                        [ 0,
                            [ "rect", "#FFFFFF",
                                [ "viewport", 50, 150 ],
                                5, 5 ] ],
                        $.va( "else" ) ) )
            ),
            
            v.sprinterAnimPut.c0( usef( function ( animState ) {
                return allAdd(
                    3 * (JSON.parse( animState ) - 1), 50 );
            }, v.drummerAnimGet.c0( a ) ) ),
            v.showShape.c0( usejf( function ( animState ) {
                return [ 0,
                    [ "rect", "#FFFFFF",
                        [ "viewport", 80 + animState, 130 ],
                        5, 5 ] ];
            }, v.sprinterAnimGet.c0( a ) ) ),
            
            v.wasdXAnimPut.c0( usef( function ( keys ) {
                var keysObj = {};
                _.arrEach( JSON.parse( keys ), function ( key ) {
                    keysObj[ key ] = true;
                } );
                var dir = (keysObj[ KEYS.d ] ? 1 : 0) -
                    (keysObj[ KEYS.a ] ? 1 : 0);
                if ( dir === -1 )
                    return allAdd( -3, 50 );
                else if ( dir === 1 )
                    return allAdd( 3, 50 );
                else
                    return [];
                // TODO: Instead of returning the invalid rule [],
                // don't apply any rule at all.
            }, v.stableKeyboard.c0( a ) ) ),
            v.wasdYAnimPut.c0( usef( function ( keys ) {
                var keysObj = {};
                _.arrEach( JSON.parse( keys ), function ( key ) {
                    keysObj[ key ] = true;
                } );
                var dir = (keysObj[ KEYS.s ] ? 1 : 0) -
                    (keysObj[ KEYS.w ] ? 1 : 0);
                if ( dir === -1 )
                    return allAdd( -3, 50 );
                else if ( dir === 1 )
                    return allAdd( 3, 50 );
                else
                    return [];
                // TODO: Instead of returning the invalid rule [],
                // don't apply any rule at all.
            }, v.stableKeyboard.c0( a ) ) ),
            v.showShape.c0( usejf( function ( animState ) {
                return [ 0,
                    [ "rect", "#FFFFFF",
                        [ "viewport",
                            80 + animState[ 0 ],
                            200 + animState[ 1 ] ],
                        5, 5 ] ];
            }, jzipTimes(
                v.wasdXAnimGet.c0( a ), v.wasdYAnimGet.c0( a ) ) ) ),
            
            $.one()
        );
    } );
    
    _.appendDom( _.el( "demo" ), canvas );
} } );
</script>
</head>
<body>
<h3>Platformer</h3>
<div id="demo"></div>
<p>Use the W key to jump. Try holding the key for different periods of
  time.</p>
<p>Use the A and D keys to move left and right.</p>
<p>TODO: Actually make this into a platform game.</p>
<p>TODO: Put a better description here.</p>
</body>
</html>
